module.exports= {body:"## 1.前置知识\n\n### 1.1 Reflect的意义\n\n\u003e JavaScript 语言内置的 Reflect 对象上的函数是为 Proxy 准备的，Proxy 的 handler 的各种 trap 分别对应 Reflect 上的同名方法。\n\u003e 在 Proxy 的 handler 中使用 Reflect 上对应的方法来实现默认行为。\n\n````javascript\nfunction logAll(o) {\n    const handler = {}\n    for (const op of Object.getOwnPropertyNames(Reflect)) {\n        handler[op] = (...args) =\u003e {\n            try {\n                return Reflect[op](...args)\n            } finally {\n                console.log(op)\n            }\n        }\n    }\n    return new Proxy(o, handler)\n}\n````\n\n### 1.2 WeakMap\n\n特点：\n\n+ WeakMap的key只能是Object类型\n+ WeakMap的key持有的是\"弱引用\"，这意味在没有其他引用存在时，垃圾回收能正确进行\n+ WeakMap的key是不可枚举的\n\n### 1.3 如何调试\n\n+ clone `vue-next`\n+ 在项目根目录运行 `yarn dev reactivity`\n+ 创建一个html文件, 然后去source面板操作\n\n````html\n\u003cscript src=\"reactivity.global.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n    const { reactive, computed } = VueReactivity\n    const r = reactive({ number: 1 })\n    debugger\n    const c = computed(() =\u003e r.number)\n    console.log(c.value)\n\u003c/script\u003e\n````\n\n阅读源码最简单有效的办法就是调试了\n\n## 2. 翻译翻译`reactive({ number: 1 })`\n\n**结论：`reactive({ number: 1 })`等价于`new Proxy({ number: 1 }, mutableHandlers)`**\n\n````javascript\nfunction reactive(target) {\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\n  const reactiveFlag = isReadonly ? \"__v_readonly\" : \"__v_reactive\";\n  const observed = new Proxy(target, baseHandlers);\n  def(target, reactiveFlag, observed);\n  return observed;\n}\n````\n\n**结论：`mutableHandlers`包含`get/set/deleteProperty/has/onwKeys`五个捕捉器，他们除了完成默认行为之外，还会调用`trigger/track`方法**\n\n````javascript\nfunction get(target, key, receiver) {\n  const res = Reflect.get(target, key, receiver);\n  track(target, \"get\" /* GET */, key);\n  // Proxy只会代理对象的第一层, 如果Reflect.get的返回值是对象，则再通过reactive方法做代理，实现更深层级的响应式\n  if (isObject(res)) {\n    return reactive(res)\n  }\n  return res;\n}\n\nfunction set(target, key, value, receiver) {\n  const oldValue = target[key];\n  value = toRaw(value);\n  const hadKey = hasOwn(target, key);\n  const result = Reflect.set(target, key, value, receiver);\n  if (!hadKey) {\n    trigger(target, \"add\" /* ADD */, key, value);\n  }\n  else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\" /* SET */, key, value, oldValue);\n  }\n  return result;\n}\n\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n  if (result \u0026\u0026 hadKey) {\n      trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\n  }\n  return result;\n}\n\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n  track(target, \"has\" /* HAS */, key);\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\" /* ITERATE */, ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nconst mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n}\n````\n\n`track/trigger`的实际作用不能孤立来看，首先需要了解`computed`的实现。\n\n## 3. 翻译翻译Computed\n\n用过`computed`的人都模糊的知道：**响应式数据更新了，计算属性就会更新**，这里有两点需要搞明白：\n\n+ 计算属性什么时候更新：是立刻更新，还是触发`get`的时候更新?\n+ 如何知道函数依赖了那些响应式数据的属性？也就是收集依赖\n\n### 3.1 计算属性什么时候更新：是立刻更新，还是触发`get`的时候更新?\n\n`computed`源码如下，这里注意`constructor`和`get`\n\n````javascript\n// 主要处理入参，赋值给getter和setter\nfunction computed(getterOrOptions) {\n  let getter;\n  let setter;\n  if (isFunction(getterOrOptions)) {\n    getter = getterOrOptions;\n    setter = NOOP;\n  }\n  else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly) {\n    this._setter = _setter;\n    // 众所周知，计算属性是有\"缓存\"的，依赖值没有改变时，当然只计算一次，_dirty可以理解为\"是否需要重新计算\"\n    this._dirty = true;\n    this.__v_isRef = true;\n    // 可以简单推测出effect的作用：getter函数中依赖的响应式数据的属性更新了，就将_dirty设置为\"需要重新计算\"的状态\n    this.effect = effect(getter, {\n      lazy: true,\n      scheduler: () =\u003e {\n        if (!this._dirty) {\n          this._dirty = true;\n          trigger(toRaw(this), \"set\" /* SET */, 'value');\n        }\n      }\n    });\n    this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\n  }\n  get value() {\n    // 需要重新计算，从effect中拿到值，否则返回缓存\n    if (this._dirty) {\n      this._value = this.effect();\n      this._dirty = false;\n    }\n    track(toRaw(this), \"get\" /* GET */, 'value');\n    return this._value;\n  }\n  // 单纯的调用一下提供的setter，不重要\n  set value(newValue) {\n    this._setter(newValue);\n  }\n}\n````\n\n**结论：计算属性不是在依赖的响应式数据变化后立即更新的，而是`get value`时按需更新**\n\n### 3.2 如何收集依赖？\n\n承接上文，在脑海中建立一个`computed =\u003e effect`的映射，`effect`接收的第一个函数，也就是`computed`中的`getter`\n\n````javascript\nfunction effect(fn, options = EMPTY_OBJ) {\n  // 避免二次包装\n  if (isEffect(fn)) {\n    fn = fn.raw;\n  }\n  const effect = createReactiveEffect(fn, options);\n  // 是否需要立即执行，从这里可见，computedRef的构造函数中初始化`effect`不会立即执行\n  if (!options.lazy) {\n    effect();\n  }\n  return effect;\n}\n\nconst effectStack = [];\nlet activeEffect;\nlet uid = 0;\n\nfunction createReactiveEffect(fn, options) {\n  const effect = function reactiveEffect() {\n    // 避免重复入栈\n    if (!effectStack.includes(effect)) {\n      // 收集依赖前，先清理一次之前effect的依赖\n      cleanup(effect);\n      try {\n        // 当前effect入栈\n        effectStack.push(effect);\n        // 维护activeEffect\n        activeEffect = effect;\n        // computed中的getter被执行，触发了响应式数据的getter，从而执行了`track`方法，收集到依赖\n        return fn();\n      }\n      finally {\n        // 当前effect出栈\n        effectStack.pop();\n        // 维护activeEffect\n        activeEffect = effectStack[effectStack.length - 1];\n      }\n    }\n  };\n  effect.id = uid++;\n  effect._isEffect = true;\n  effect.active = true;\n  effect.raw = fn;\n  effect.deps = [];\n  effect.options = options;\n  return effect;\n}\n````\n\n**结论：在执行effect函数时，最终会调用原始函数`fn`，此时会触发响应式数据的`getter`, 进而调用`track`函数，完成依赖收集**\n\n## 4. 依赖表\n\n依赖收集的数据结构`targetMap`整体是一个`WeakMap`，`key`为响应式对象，`value`为`Map\u003c被依赖的属性，Set\u003cReactiveEffect\u003e\u003e`\n\n````typescript\n// The main WeakMap that stores {target -\u003e key -\u003e dep} connections.\n// Conceptually, it's easier to think of a dependency as a Dep class\n// which maintains a Set of subscribers, but we simply store them as\n// raw Sets to reduce memory overhead.\ntype Dep = Set\u003cReactiveEffect\u003e\ntype KeyToDepMap = Map\u003cany, Dep\u003e\nconst targetMap = new WeakMap\u003cany, KeyToDepMap\u003e()\n````\n\n### 4.1 track函数\n\n维护依赖表\n\n````javascript\nfunction track(target, type, key) {\n  if (!shouldTrack || activeEffect === undefined) {\n    return;\n  }\n  let depsMap = targetMap.get(target);\n  if (!depsMap) {\n    targetMap.set(target, (depsMap = new Map()));\n  }\n  let dep = depsMap.get(key);\n  if (!dep) {\n    depsMap.set(key, (dep = new Set()));\n  }\n  if (!dep.has(activeEffect)) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n  }\n}\n````\n\n### 4.2 trigger函数\n\n从依赖表中取出对应的`effects`，执行\n\n````javascript\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  // 这一堆代码就是找effects罢了\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  const effects = new Set();\n  const add = (effectsToAdd) =\u003e {\n    if (effectsToAdd) {\n      effectsToAdd.forEach(effect =\u003e {\n        if (effect !== activeEffect) {\n          effects.add(effect);\n        }\n      });\n    }\n  };\n  if (key !== void 0) {\n    add(depsMap.get(key));\n  }\n  // 如果提供了调度函数，就执行调度函数\n  const run = (effect) =\u003e {\n    if (effect.options.scheduler) {\n      effect.options.scheduler(effect);\n    }\n    else {\n      effect();\n    }\n  };\n  // 全都执行一遍\n  effects.forEach(run);\n}\n````\n\n## 5. 整体流程回顾\n\n+ `const r = reactive({ number: 1 })`\n  + 创建了一个响应式数据：实际等于`new Proxy(target, mutableHandlers)`，`mutableHandlers`包含`get/set/ownKeys/has/deleteProperty`捕获器，他们会调用`track/trigger`方法\n+ `const c = computed(() =\u003e r.number)`\n  + 创建了一个计算属性：实际上初始化了一个`effect(() =\u003e r.number, { lazy: true, scheduler: 略 })`函数, 但是并没有执行，此时`c.value`实际为`undefined`\n+ `console.log(c.value)`\n  + 首次获取计算属性的值，让`effect(() =\u003e r.number, { lazy: true, scheduler: 略 })`得到执行，并在最终执行`() =\u003e r.number`时，触发了响应式数据`c`的`getter`\n  + 收集到了依赖：`track(r, 'get', 'number')`\n  + 此时依赖表为：\n    |  reactiveObj | reactiveAttribute | effects |\n    |  ----  | ---- | ---- |\n    | r | number | effect(() =\u003e r.number, { lazy: true, scheduler: 略 }) |\n+ `r.number = 10`\n  + 触发了响应式对象r的`setter`\n  + 触发更新：`trigger(r, 'set', 'number', 10, 1)`\n  + 从依赖表中取出对应reactiveObj, reactiveAttribute下的`effects`执行\n  + 在这个例子中执行`effect.options.scheduler`函数，将`computedRef`的`_dirty`属性设置为\"需要更新的状态\"\n+ `console.log(c.value)`\n  + 第二次获取计算属性的值，由于`_dirty`为\"需要更新的状态\"，所以再次执行`effect`函数获取新值\n  \n\n\n\n\n\n\n\n"}